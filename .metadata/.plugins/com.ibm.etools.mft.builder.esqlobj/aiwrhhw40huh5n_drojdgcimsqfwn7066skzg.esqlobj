CREATE COMPUTE MODULE measurementHistoryMultiline_MapToJSONModel
CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL CopyMessageHeaders();
		--CALL CopyEntireMessage();

		DECLARE response REFERENCE TO InputRoot.XMLNSC.ns:senderResponse;
		DECLARE errorResponse REFERENCE TO InputRoot.XMLNSC.ns:senderResponse;
		--GESTIONE ERRORE
		MOVE errorResponse FIRSTCHILD NAME 'error';
		IF LASTMOVE(errorResponse) THEN
			SET OutputLocalEnvironment.Destination.HTTP.ReplyStatusCode = 400;
			SET OutputRoot.JSON.Data.errorCode = errorResponse.errorCode;
			SET OutputRoot.JSON.Data.errorMessage = errorResponse.errorMessage;
			RETURN TRUE;
		END IF; 

		SET OutputLocalEnvironment.Destination.HTTP.ReplyStatusCode = 200;

		--MAP MODEL TO JSON
		MOVE response FIRSTCHILD;

		IF LASTMOVE(response) THEN
			MOVE response FIRSTCHILD NAMESPACE ns NAME 'parameter';	
			--array di misurazioni
			DECLARE refOutJSON REFERENCE TO OutputRoot;
			DECLARE refMeasures REFERENCE TO OutputRoot;
			DECLARE measure ROW;
			DECLARE uscita ROW;
			DECLARE misure ROW;
			DECLARE multiline ROW;
			DECLARE risposta ROW;
			
						
			DECLARE dateToday TIMESTAMP;
			SET dateToday = CAST (CURRENT_TIMESTAMP AS TIMESTAMP FORMAT 'YYYY-MM-dd HH.mm.ss');
			DECLARE dateSeven TIMESTAMP;
			DECLARE retAge CHARACTER '7';
			SET dateSeven = dateToday - CAST(retAge AS INTERVAL DAY);
			DECLARE indiceProv INTEGER 1;
			
			
			CREATE FIELD OutputRoot.JSON.Data AS refOutJSON IDENTITY (JSON.Array)Data;
			DECLARE ind INTEGER 1;
 			WHILE LASTMOVE(response) DO
 				DECLARE refValues REFERENCE TO response;
				MOVE refValues FIRSTCHILD NAMESPACE ns NAME 'values';
				DECLARE responseDate TIMESTAMP CAST(response.date AS TIMESTAMP FORMAT 'YYYY-MM-dd HH.mm.ss');
				DECLARE detectionPointID CHARACTER;
				DECLARE detectionPointDescription CHARACTER;
				
				
				IF NULLIF(refValues.measureId,'NINF001') IS NOT NULL AND NULLIF(refValues.measureId,'IINF001') IS NOT NULL AND NULLIF(refValues.measureId,'NINF101') IS NOT NULL THEN 
			 			WHILE LASTMOVE(refValues) DO
			 				IF NULLIF(refValues.value,'') IS NOT NULL 
			 					AND NULLIF(refValues.measureId,'') IS NOT NULL 
			 					AND NULLIF(refValues.value,'null') IS NOT NULL 
			 					AND responseDate > dateSeven
			 					THEN
			 					DECLARE refMeasureId REFERENCE TO measure;
			 					DECLARE multiId REFERENCE TO multiline;
			 					IF (refValues.measureId = 'DN999') THEN
			 						SET detectionPointID = refValues.value;
			 						SET detectionPointDescription = 'DreinageNumber';
			 					END IF;
			 					IF NULLIF (detectionPointID, '') IS NOT NULL THEN
			 						DECLARE PROVA CHARACTER;
			 					ELSE
			 						SET detectionPointID = indiceProv;
			 						SET indiceProv = indiceProv +1;
			 					END IF;
			 					IF NULLIF (detectionPointDescription, '') IS NOT NULL THEN
			 						DECLARE PROVA CHARACTER;
			 					ELSE
			 						SET detectionPointDescription = '';
			 					END IF;
			 					IF (refValues.measureId = 'DN012') THEN
										
			 							
										CREATE FIRSTCHILD OF refValues NAME detectionPointID VALUE detectionPointID;
										SET refValues.detectionPointID = detectionPointID;

					 					MOVE refMeasureId FIRSTCHILD NAME refValues.measureId;
					 					MOVE multiId FIRSTCHILD NAME refValues.measureId;  --luca multiline
					 					IF NOT LASTMOVE(refMeasureId) THEN
					 						CREATE LASTCHILD OF measure AS refMeasureId NAME refValues.measureId;
					 						CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'measureId' VALUE refValues.measureId;
					 						CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'measureName' VALUE refValues.measureName;
					 						
					 						--luca multiline
					 						CREATE LASTCHILD OF multiline AS multiId NAME refValues.measureId;
					 						CREATE LASTCHILD OF multiId TYPE NameValue NAME 'measureId' VALUE refValues.measureId;
					 						CREATE LASTCHILD OF multiId TYPE NameValue NAME 'measureName' VALUE refValues.measureName;
					 						--

					 					END IF;
					 					
					 					--CREATE LASTCHILD OF refMeasureId AS refMeasureId NAME 'measurements';
					 					MOVE refMeasureId FIRSTCHILD NAME refValues.detectionPointID;
					 					
					 					--luca multiline
					 					MOVE multiId FIRSTCHILD NAME refValues.detectionPointID;
										--
					 					
										IF NOT LASTMOVE(refMeasureId) THEN
											--CREATE LASTCHILD OF refMeasureId AS refMeasureId NAME 'measurements';--prima
											CREATE LASTCHILD OF refMeasureId AS refMeasureId NAME detectionPointID;--per creare un unico measurements con due values
											CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'detectionPointID' VALUE detectionPointID;
											CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'detectionPointDescription' VALUE detectionPointDescription;
											
											--multiline
											--MOVE LASTMOVE multiId;
											CREATE LASTCHILD OF multiId AS multiId NAME 'measurements';
											CREATE LASTCHILD OF multiId TYPE NameValue NAME 'detectionPointID' VALUE detectionPointID;
											CREATE LASTCHILD OF multiId TYPE NameValue NAME 'detectionPointDescription' VALUE detectionPointDescription;
											--
										END IF;
										
				 						CREATE LASTCHILD OF refMeasureId AS refMeasureId NAME 'values';
										CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'taskId' VALUE response.taskId;
										CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'userId' VALUE response.userId;
										CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'value' VALUE refValues.value;
										CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'date' VALUE response.date;
										IF (refValues.units IS NOT NULL) THEN
											CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'units' VALUE refValues.units;
										END IF;
										IF (refValues.type IS NOT NULL) THEN
											CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'type' VALUE refValues.type;
										END IF;
										
										--multiline
										
										--MOVE multiId NEXTSIBLING;
										CREATE LASTCHILD OF multiId AS multiId NAME 'values';
										CREATE LASTCHILD OF multiId TYPE NameValue NAME 'taskId' VALUE response.taskId;
										CREATE LASTCHILD OF multiId TYPE NameValue NAME 'userId' VALUE response.userId;
										CREATE LASTCHILD OF multiId TYPE NameValue NAME 'value' VALUE refValues.value;
										CREATE LASTCHILD OF multiId TYPE NameValue NAME 'date' VALUE response.date;
										IF (refValues.units IS NOT NULL) THEN
											CREATE LASTCHILD OF multiId TYPE NameValue NAME 'units' VALUE refValues.units;
										END IF;
										IF (refValues.type IS NOT NULL) THEN
											CREATE LASTCHILD OF multiId TYPE NameValue NAME 'type' VALUE refValues.type;
										END IF;
										--
					 					

										
								END IF;								
			 				END IF;
			 				MOVE refValues NEXTSIBLING REPEAT NAME;
			 			END WHILE;
			 	END IF;

				SET ind = ind + 1;
				MOVE response NEXTSIBLING;
	 		END WHILE;
	 		
	 		
	 		
	 		
	 		DECLARE nuovi REFERENCE TO measure;
	 		MOVE nuovi FIRSTCHILD;	
	 		
	 		--MOVE nuovi FIRSTCHILD NAMESPACE ns NAME 'measurements';	
	 		--IF LASTMOVE(nuovi) THEN
			--MOVE nuovi FIRSTCHILD NAMESPACE ns NAME 'measurements';	
	 		--END IF;
	 		DECLARE r INTEGER 1;
	 		--MOVE measure FIRSTCHILD;
	 		--CREATE LASTCHILD OF uscita NAME 'root';
	 		--MOVE uscita FIRSTCHILD NAME 'root';
	 		
	 		--MOVE uscita FIRSTCHILD;
	 		FOR source AS nuovi.measurements[]  DO
	 			--CREATE FIRSTCHILD OF uscita NAME 'measurements';
	 			
	 			--CREATE FIRSTCHILD OF uscita AS uscita TYPE NameValue NAME 'detectionPointID' VALUE nuovi.measurements[r].detectionPointID;
	 			SET uscita.root.measurements[r] = nuovi.measurements[r];
		 		SET r = r + 1;
			END FOR;
			DECLARE luca REFERENCE TO uscita;
			MOVE luca FIRSTCHILD;
			IF LASTMOVE(luca) THEN
				
				MOVE luca FIRSTCHILD NAME 'measurements';	
				DECLARE indice INTEGER 1;
 				WHILE LASTMOVE(luca) DO
 					DECLARE refValues REFERENCE TO luca;
 					DECLARE detPointTemp CHARACTER;
					SET detPointTemp = refValues.detectionPointID;
					MOVE refValues FIRSTCHILD NAME 'values';
					SET refValues.detectionPointID = detPointTemp;
 					WHILE LASTMOVE(refValues) DO
 						DECLARE refMeasureId REFERENCE TO misure;
 						MOVE refMeasureId FIRSTCHILD NAME refValues.detectionPointID;
 						IF NULLIF(refValues.detectionPointID,'') IS NOT NULL THEN
 							IF NOT LASTMOVE(refMeasureId) THEN
						 		CREATE LASTCHILD OF misure AS refMeasureId NAME 'measurements';--refValues.detectionPointID;
						 		CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'detectionPointID' VALUE refValues.detectionPointID;
					 		END IF;
 						ELSE
							CREATE LASTCHILD OF misure AS refMeasureId NAME 'measurements';--refValues.detectionPointID;
						 	CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'detectionPointID' VALUE refValues.detectionPointID;
					 		
					 	END IF;
 						
--					 	IF NOT LASTMOVE(refMeasureId) THEN
--					 		CREATE LASTCHILD OF misure AS refMeasureId NAME 'measurements';--refValues.detectionPointID;
--					 		CREATE LASTCHILD OF refMeasureId TYPE NameValue NAME 'detectionPointID' VALUE refValues.detectionPointID;
--					 		
--					 	END IF;
					 	MOVE refValues NEXTSIBLING REPEAT NAME;
 					END WHILE;
 					SET indice = indice + 1;
					MOVE luca NEXTSIBLING;
				END WHILE;
			END IF;
			--DECLARE duplicato REFERENCE TO uscita;
--			DECLARE w INTEGER 1;
--			--MOVE uscita FIRSTCHILD;	
--		--IF LASTMOVE(uscita) THEN
----				MOVE uscita FIRSTCHILD NAMESPACE ns NAME 'measurements';	
------				DECLARE figli REFERENCE TO uscita;
--				DECLARE indice INTEGER 1;
--				--WHILE LASTMOVE(uscita) DO
--				FOR source AS uscita.measurements[]  DO
--					DECLARE figlio REFERENCE TO uscita.measurements[indice];
--					--MOVE duplicato FIRSTCHILD NAME 'detectionPointID';
--					--MOVE uscita.measurements[indice] FIRSTCHILD;-- NAME 'detectionPointID';
--					IF NOT LASTMOVE(figlio) THEN
--						set w = w+1;
--					END IF;
--					SET indice = indice + 1;
--				END FOR;
					--MOVE figli NEXTSIBLING;
			 	--END WHILE;
		--END IF;
			
			DECLARE pr CHARACTER;
	 		SET refOutJSON = measure;
	 		--SET refOutJSON = multiline;
	 		CALL createJSONArrays(OutputRoot.JSON.Data);
			RETURN TRUE;
			
		END IF;
	

		SET OutputLocalEnvironment.Destination.HTTP.ReplyStatusCode = 200;
		--CREATE LASTCHILD OF OutputRoot Domain('JSON');
		--SET OutputRoot.JSON.Data.ns:senderResponse.error.errorCode = 1;
		RETURN TRUE;
	END;

	CREATE PROCEDURE CopyMessageHeaders() BEGIN
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			SET OutputRoot.*[I] = InputRoot.*[I];
			SET I = I + 1;
		END WHILE;
	END;

	CREATE PROCEDURE CopyEntireMessage() BEGIN
		SET OutputRoot = InputRoot;
	END;
	
	-- Walk the tree recursively starting at inRef. 
	-- Replace all sequences of same-named elements with a JSON array.
	-- A JSON array has a name and some child elements with values. 
	-- The array element must have field type JSON.Array.
	-- The child elements that hold the values can optionally have names. 
	CREATE PROCEDURE createJSONArrays(IN root REFERENCE ) 
	BEGIN
		-- track the start and end of 'arrays' ( sequences of same-named siblings )
		DECLARE firstArrayElementRef REFERENCE TO root;
		DECLARE siblingRef REFERENCE TO root;
		DECLARE arraySize INTEGER 0;


		DECLARE SIBLI CHARACTER FIELDNAME(siblingRef);
		DECLARE FIRST CHARACTER FIELDNAME(firstArrayElementRef);

		WHILE LASTMOVE(siblingRef) DO
			
			-- Process any child elements first 
			DECLARE firstChildRef REFERENCE TO siblingRef;
			MOVE firstChildRef FIRSTCHILD;
			IF LASTMOVE(firstChildRef) THEN
				CALL createJSONArrays(firstChildRef);
			END IF;
			SET SIBLI = FIELDNAME(siblingRef);
			SET FIRST = FIELDNAME(firstArrayElementRef);
			-- IF this sibling's name is different from the previous one.
			IF FIELDNAME(siblingRef) = FIELDNAME(firstArrayElementRef) THEN
				SET arraySize = arraySize + 1;
			ELSE
				-- IF there was a sequence of two or more siblings with the same name
				IF arraySize > 1 OR FIELDNAME(firstArrayElementRef) = 'values' THEN
					CALL createJSONArray(firstArrayElementRef, arraySize);
				END IF;				

				-- start scanning for a new array
				MOVE firstArrayElementRef TO siblingRef;
				SET arraySize = 1;
			END IF;
			
			MOVE siblingRef NEXTSIBLING;
		END WHILE;
		SET FIRST = FIELDNAME(firstArrayElementRef);
		
		IF arraySize > 1 OR FIELDNAME(firstArrayElementRef) = 'values' THEN
			CALL createJSONArray(firstArrayElementRef, arraySize);
		END IF;
	END;

	CREATE PROCEDURE createJSONArray(IN firstArrayElementRef REFERENCE, IN arraySize INTEGER) BEGIN
		-- Create a parent element for the array
		DECLARE arrayParentRef REFERENCE TO firstArrayElementRef;
		CREATE PREVIOUSSIBLING OF firstArrayElementRef 
			AS arrayParentRef 
			TYPE JSON.Array 
			NAMESPACE FIELDNAMESPACE(firstArrayElementRef) 
			NAME FIELDNAME(firstArrayElementRef);
			
		-- Make the array members children of the new parent element
		DECLARE pos INTEGER 1;
		WHILE pos <= arraySize DO
			DECLARE tempRef REFERENCE TO firstArrayElementRef;
			-- advance the reference. This should never fail because we have
			-- already walked all of these siblings to discover the array.
			MOVE firstArrayElementRef NEXTSIBLING;

			DETACH tempRef;
			ATTACH tempRef TO arrayParentRef AS LASTCHILD;
			
			SET pos = pos + 1;
		END WHILE;
	END;
	
END MODULE;